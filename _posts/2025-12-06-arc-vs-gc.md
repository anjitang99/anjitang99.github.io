---
title: Swift ARC vs Java GC - 메모리 관리 방식의 근본적 차이
date: 2025-12-06 20:00:00 +0900
categories:
  - iOS
  - Swift
tags:
  - ARC
  - GarbageCollector
  - 메모리관리
  - Swift
  - Java
  - 성능최적화
pin: false
---

## 들어가며

뺀질대다가 결국 3주나 지나서야 글을 쓰게된다 ㅜㅜ 각설하고 ARC를 공부하다 보니 백엔드에서 써먹었던(?)이라기 보단 JVM에서 알아서 해줬던 GC와 ARC가 다른 점이 무엇인가 먼저 정리해 보는것도 좋을것 같다.  
다시 관련 공부를 하기위해 야곰 스위프트 기본책을 다시 한번 정독하고 관련 내용을 정리해보려고 한다.

## ARC와 GC, 무엇이 다른가?

### 기본 개념

**ARC (Automatic Reference Counting)**
- Swift와 Objective-C에서 사용하는 메모리 관리 방식
- **컴파일 타임**에 메모리 관리 코드가 자동으로 삽입됨
- 참조 카운트(Reference Count)를 통해 메모리를 관리

**GC (Garbage Collector)**
- Java, C#, Go 등에서 사용하는 메모리 관리 방식
- **런타임**에 별도의 가비지 컬렉터 스레드가 동작
- 도달 불가능한(unreachable) 객체를 주기적으로 수집

> 한마디로, ARC는 프로그램이 수행되기전에 이미 언제 해제될지가 결정되어있다!
{: .prompt-info }

### 핵심 차이점: 언제 메모리를 해제하는가?

```swift
// Swift - ARC
class Person {
    let name: String
    init(name: String) {
        self.name = name
        print("\(name) 생성")
    }
    deinit {
        print("\(name) 해제") // 참조 카운트가 0이 되는 즉시 호출
    }
}

var person1: Person? = Person(name: "John")  // RC: 1
var person2 = person1                         // RC: 2
person1 = nil                                 // RC: 1
person2 = nil                                 // RC: 0 → 즉시 deinit 호출
```

```java
// Java - GC
class Person {
    private String name;

    public Person(String name) {
        this.name = name;
        System.out.println(name + " 생성");
    }

    @Override
    protected void finalize() {
        System.out.println(name + " 해제"); // GC가 언제 호출할지 불확실
    }
}

Person person1 = new Person("John");
Person person2 = person1;
person1 = null;
person2 = null;  // 이 시점에 바로 해제되지 않음
                 // GC가 나중에 수집할 때 해제됨
```

## 동작 방식 비교

### ARC의 동작 방식

ARC는 **컴파일러**가 코드를 분석하여 자동으로 `retain`(참조 증가)과 `release`(참조 감소) 코드를 삽입한다.

```swift
// 개발자가 작성한 코드
func createPerson() {
    let person = Person(name: "John")
    print(person.name)
}

// 컴파일러가 실제로 생성하는 코드 (개념적으로)
func createPerson() {
    let person = Person(name: "John")  // retain (RC: 1)
    print(person.name)
    // release (RC: 0 → 즉시 메모리 해제)
}
```

**특징:**
- 참조 카운트가 0이 되면 **즉시** 메모리 해제
- 메모리 해제 시점이 **결정적(deterministic)**
- 별도의 GC 스레드가 필요 없음
- 오버헤드가 낮고 예측 가능

### GC의 동작 방식

GC는 **런타임**에 별도의 스레드가 주기적으로 또는 메모리가 부족할 때 실행된다.

```java
// Java의 GC 동작 (개념적)
1. 애플리케이션 실행 중...
2. 힙 메모리가 일정 수준 이상 사용됨
3. GC가 트리거됨
4. Stop-the-World: 애플리케이션 일시 중지
5. 도달 가능한 객체 마킹 (Mark)
6. 도달 불가능한 객체 수집 (Sweep)
7. 메모리 압축 (Compact) - 선택적
8. 애플리케이션 재개
```

**특징:**
- 메모리 해제 시점이 **비결정적(non-deterministic)**
- Stop-the-World[^1]로 인한 성능 영향 가능
- 순환 참조를 자동으로 처리
- 메모리 사용량이 더 많을 수 있음

## 성능 비교

### ARC의 장점

**1. 예측 가능한 성능**
```swift
// 메모리 해제 시점이 명확함
func processLargeData() {
    let data = LargeDataSet()  // 메모리 할당
    data.process()
    // 함수 종료 시 즉시 메모리 해제
}
```

**2. Stop-the-World 없음**
- 앱이 일시 중지되는 일이 없음
- 부드러운 60fps/120fps UI 유지에 유리
- 실시간 반응성이 중요한 게임, 금융 앱에 적합

**3. 낮은 메모리 오버헤드**
- 객체당 추가 메모리: 8바이트 (참조 카운트 저장)
- GC 메타데이터가 필요 없음

### GC의 장점

**1. 순환 참조 자동 처리**
```java
// Java - 순환 참조가 있어도 GC가 자동으로 처리
class Node {
    Node next;
}

Node node1 = new Node();
Node node2 = new Node();
node1.next = node2;
node2.next = node1;  // 순환 참조

node1 = null;
node2 = null;
// GC가 두 객체 모두 수집 가능함을 인식하고 해제
```

```swift
// Swift - 순환 참조 발생 시 메모리 누수
class Node {
    var next: Node?  // strong reference
}

var node1: Node? = Node()
var node2: Node? = Node()
node1?.next = node2
node2?.next = node1  // 순환 참조

node1 = nil
node2 = nil
// 메모리 누수 발생! weak 또는 unowned 사용 필요
```

**2. 개발자가 메모리 관리를 덜 신경 써도 됨**
- 순환 참조 걱정이 적음
- `weak`, `unowned` 같은 키워드를 사용할 필요 없음

**3. 메모리 압축**
- 메모리 단편화 방지
- 메모리 공간을 더 효율적으로 사용

## 실제 사례 비교

### 케이스 1: 대량 데이터 처리

**ARC의 경우:**
```swift
func processBigData() {
    for i in 0..<1000 {
        let data = HeavyObject()  // RC: 1
        data.process()
        // 루프 반복마다 즉시 메모리 해제
    }
    // 메모리 사용량이 일정하게 유지
}
```

**GC의 경우:**
```java
void processBigData() {
    for (int i = 0; i < 1000; i++) {
        HeavyObject data = new HeavyObject();
        data.process();
        // 객체가 계속 힙에 쌓임
    }
    // GC가 트리거되면 한 번에 처리
    // 메모리 사용량이 톱니 모양으로 증가/감소
}
```

### 케이스 2: UI 스크롤 성능

**ARC:**
```swift
// TableView 스크롤 시
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
    let cell = tableView.dequeueReusableCell(withIdentifier: "Cell", for: indexPath)
    let image = loadImage(at: indexPath)  // RC: 1
    cell.imageView?.image = image
    return cell
    // image는 cell이 재사용될 때 즉시 해제
    // 부드러운 60fps 유지
}
```

**GC:**
- 스크롤 중 GC가 트리거되면 프레임 드롭 가능
- Stop-the-World로 인한 버벅임 발생 가능
- 최신 GC는 이를 최소화하도록 개선됨 (Concurrent GC 등)

## 각자의 약점과 해결책

### ARC의 약점: 순환 참조 (Retain Cycle)

**문제:**
```swift
class Person {
    var apartment: Apartment?
}

class Apartment {
    var tenant: Person?
}

var john: Person? = Person()
var unit4A: Apartment? = Apartment()
john?.apartment = unit4A
unit4A?.tenant = john  // 순환 참조 발생

john = nil
unit4A = nil
// 둘 다 메모리에서 해제되지 않음!
```

**해결책:**
```swift
class Person {
    var apartment: Apartment?
}

class Apartment {
    weak var tenant: Person?  // weak 사용
}

var john: Person? = Person()
var unit4A: Apartment? = Apartment()
john?.apartment = unit4A
unit4A?.tenant = john

john = nil  // Person 해제됨
unit4A = nil  // Apartment도 해제됨
```

**weak vs unowned:**
```swift
// weak: 옵셔널 타입, 참조가 nil이 될 수 있음
weak var delegate: MyDelegate?

// unowned: 논옵셔널 타입, 참조가 항상 유효하다고 가정
unowned let owner: Owner
```

### GC의 약점: 예측 불가능한 지연

**문제:**
```java
// 중요한 트랜잭션 처리 중
void processPayment() {
    Payment payment = new Payment();
    payment.process();
    // 여기서 GC가 트리거되면?
    // Stop-the-World로 인한 지연 발생
}
```

**해결책:**
1. GC 튜닝 (Heap 크기 조정, GC 알고리즘 선택)
2. 객체 풀링 (Object Pooling)
3. Off-heap 메모리 사용
4. 최신 GC 사용 (G1GC, ZGC, Shenandoah 등)

## ARC 사용 시 주의사항

ARC는 강력하지만, 순환 참조(Retain Cycle) 문제를 주의해야 한다. 다음과 같은 상황에서 순환 참조가 발생할 수 있다:

1. **클로저에서의 순환 참조**: 클로저가 `self`를 강하게 캡처하면 순환 참조 발생 → `[weak self]` 또는 `[unowned self]` 사용
2. **Delegate 패턴**: Delegate 프로퍼티는 `weak`으로 선언하여 순환 참조 방지
3. **타이머와 순환 참조**: Timer가 대상 객체를 강하게 참조하므로 클로저에서 `weak self` 필요

> 순환 참조를 방지하는 구체적인 방법과 디버깅 기법은 다음 포스트에서 자세히 다룰 예정이다.
{: .prompt-tip }

## GC vs ARC: 어느 것이 더 나은가?

정답은 **"상황에 따라 다르다"**이다.

### ARC가 유리한 경우
- 실시간 성능이 중요한 애플리케이션 (게임, 금융 앱, AR/VR)
- 예측 가능한 메모리 해제가 필요한 경우
- 메모리가 제한적인 환경 (모바일 기기)
- UI 반응성이 최우선인 경우

### GC가 유리한 경우
- 복잡한 객체 그래프를 다루는 경우
- 개발 속도가 중요한 경우
- 메모리가 충분한 서버 환경
- 순환 참조가 빈번히 발생하는 구조

## 마치며

백엔드에서 iOS로 넘어오면서 가장 큰 차이점 중 하나가 바로 이 메모리 관리 방식이었다. Java의 GC는 "알아서 해주는 편한 것"이었지만, Swift의 ARC는 "제대로 이해해야 하는 것"이었다.

다음 포스트에서는 ARC의 메모리 누수를 해결하는 방법에 대해 다뤄보겠다.

## 참고 자료

- [Swift Language Guide - Automatic Reference Counting](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html)
- [Understanding Swift Performance (WWDC 2016)](https://developer.apple.com/videos/play/wwdc2016/416/)
- [Java Garbage Collection Basics](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)
- [Memory Management in iOS](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html)

---

[^1]: **Stop-the-World(STW)**: GC가 메모리를 정리하는 동안 애플리케이션의 모든 스레드를 일시 중지시키는 현상. GC가 안전하게 메모리를 정리하려면 힙의 상태를 고정해야 하기 때문에 발생한다. 최신 GC(G1GC, ZGC 등)는 이 시간을 최소화하려고 노력한다.
